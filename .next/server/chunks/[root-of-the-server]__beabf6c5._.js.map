{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/techs/Downloads/nextjs_1%20%282%29/nextjs_1/src/lib/siteAClient.js"],"sourcesContent":["export const sendTransactionToSiteB = async (transactionPayload) => {\r\n  try {\r\n    const SITE_A_PROXY_ENDPOINT = \"/api/transactions\";\r\n    const BEARER_TOKEN = process.env.NEXT_PUBLIC_BEARER_TOKEN || \"testtoken123\";\r\n    const SHARED_SECRET = process.env.SHARED_SECRET || \"mytransactionsecratekeyinder81\";\r\n\r\n    // Ensure complete payload\r\n    const completePayload = {\r\n      txnId: transactionPayload.txnId || `TXN-${Date.now()}`,\r\n      payerName: transactionPayload.payerName || \"Unknown User\",\r\n      payerEmail: transactionPayload.payerEmail || \"unknown@example.com\",\r\n      amount: transactionPayload.amount || 0,\r\n      description: transactionPayload.description || \"Payment\",\r\n      type: transactionPayload.type || \"PAYMENT\",\r\n      referenceId: transactionPayload.referenceId || \"REF-${Date.now()}\",\r\n      currency: transactionPayload.currency || \"INR\",\r\n      status: transactionPayload.status || \"UNKNOWN\",\r\n      responseMessage: transactionPayload.responseMessage || \"\",\r\n      userId: transactionPayload.userId || \"\",\r\n      metadata: transactionPayload.metadata || {},\r\n      statusCode: transactionPayload.statusCode || \"PENDING\",\r\n      createdAt: transactionPayload.createdAt || new Date().toISOString(),\r\n    };\r\n\r\n    console.log(\"Sending to Site B:\", SITE_A_PROXY_ENDPOINT, completePayload);\r\n\r\n    const response = await fetch(SITE_A_PROXY_ENDPOINT, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        \"Authorization\": `Bearer ${BEARER_TOKEN}`,\r\n        \"x-shared-secret\": SHARED_SECRET,\r\n      },\r\n      body: JSON.stringify(completePayload),\r\n    });\r\n\r\n    const responseText = await response.text();\r\n    console.log(\"Raw Response:\", responseText);\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Site B Error (Status ${response.status}): ${responseText}`);\r\n    }\r\n\r\n    let data;\r\n    try {\r\n      data = JSON.parse(responseText);\r\n    } catch {\r\n      data = { raw: responseText };\r\n    }\r\n\r\n    console.log(\"Parsed Response:\", data);\r\n    return data;\r\n  } catch (error) {\r\n    console.error(\"Failed to send transaction:\", error.message);\r\n    throw error;\r\n  }\r\n};\r\n"],"names":[],"mappings":";;;AAAO,MAAM,yBAAyB,OAAO;IAC3C,IAAI;QACF,MAAM,wBAAwB;QAC9B,MAAM,eAAe,uDAAwC;QAC7D,MAAM,gBAAgB,QAAQ,GAAG,CAAC,aAAa,IAAI;QAEnD,0BAA0B;QAC1B,MAAM,kBAAkB;YACtB,OAAO,mBAAmB,KAAK,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,IAAI;YACtD,WAAW,mBAAmB,SAAS,IAAI;YAC3C,YAAY,mBAAmB,UAAU,IAAI;YAC7C,QAAQ,mBAAmB,MAAM,IAAI;YACrC,aAAa,mBAAmB,WAAW,IAAI;YAC/C,MAAM,mBAAmB,IAAI,IAAI;YACjC,aAAa,mBAAmB,WAAW,IAAI;YAC/C,UAAU,mBAAmB,QAAQ,IAAI;YACzC,QAAQ,mBAAmB,MAAM,IAAI;YACrC,iBAAiB,mBAAmB,eAAe,IAAI;YACvD,QAAQ,mBAAmB,MAAM,IAAI;YACrC,UAAU,mBAAmB,QAAQ,IAAI,CAAC;YAC1C,YAAY,mBAAmB,UAAU,IAAI;YAC7C,WAAW,mBAAmB,SAAS,IAAI,IAAI,OAAO,WAAW;QACnE;QAEA,QAAQ,GAAG,CAAC,sBAAsB,uBAAuB;QAEzD,MAAM,WAAW,MAAM,MAAM,uBAAuB;YAClD,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,iBAAiB,CAAC,OAAO,EAAE,cAAc;gBACzC,mBAAmB;YACrB;YACA,MAAM,KAAK,SAAS,CAAC;QACvB;QAEA,MAAM,eAAe,MAAM,SAAS,IAAI;QACxC,QAAQ,GAAG,CAAC,iBAAiB;QAE7B,IAAI,CAAC,SAAS,EAAE,EAAE;YAChB,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,SAAS,MAAM,CAAC,GAAG,EAAE,cAAc;QAC7E;QAEA,IAAI;QACJ,IAAI;YACF,OAAO,KAAK,KAAK,CAAC;QACpB,EAAE,OAAM;YACN,OAAO;gBAAE,KAAK;YAAa;QAC7B;QAEA,QAAQ,GAAG,CAAC,oBAAoB;QAChC,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B,MAAM,OAAO;QAC1D,MAAM;IACR;AACF","debugId":null}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/techs/Downloads/nextjs_1%20%282%29/nextjs_1/src/app/api/payment/callback/route.js"],"sourcesContent":["import { NextResponse } from 'next/server'\r\nimport crypto from 'node:crypto'\r\nimport { sendTransactionToSiteB } from '@/lib/siteAClient'\r\n\r\n// Server-side compatible decryption function\r\nfunction decryptSabPaisaResponse(encResponse, authKey, authIV) {\r\n  try {\r\n    // Decode base64 strings for key and IV\r\n    const key = Buffer.from(authKey || 'doJx8Ihyb2s/sh1pbYEDfa6JdsogEYMXKEoPF/BEwrg=', 'base64')\r\n    const fullIV = Buffer.from(authIV || 'iw/0vT01OWRph/rQplst/W7k423JXrgo4xBn3gXPsIDXTTXE461f4V4QYKGQ8wTe', 'base64')\r\n    \r\n    // IV must be exactly 16 bytes for AES-256-CBC\r\n    const iv = fullIV.slice(0, 16)\r\n    \r\n    // Log input details for debugging\r\n    console.log('Input details:', {\r\n      encResponseLength: encResponse ? encResponse.length : 0,\r\n      keyLength: key.length,\r\n      ivLength: iv.length,\r\n      isHex: /^[0-9A-Fa-f]+$/.test(encResponse || ''),\r\n    })\r\n    \r\n    // If no encrypted response, return a mock response for testing\r\n    if (!encResponse) {\r\n      console.log('No encrypted response provided, returning mock data')\r\n      return {\r\n        status: 'success',\r\n        message: 'This is a mock response for testing',\r\n        txnId: 'MOCK_TXN_' + Date.now(),\r\n        amount: '100.00',\r\n        paymentMode: 'TEST',\r\n        paymentDateTime: new Date().toISOString()\r\n      }\r\n    }\r\n    \r\n    // SabPaisa specific handling - try multiple approaches\r\n    \r\n    // APPROACH 1: Try with custom padding for SabPaisa format\r\n    try {\r\n      // Convert hex to buffer\r\n      const encryptedData = Buffer.from(encResponse, 'hex')\r\n      \r\n      // Calculate padding needed for AES block size (16 bytes)\r\n      const blockSize = 16\r\n      const remainder = encryptedData.length % blockSize\r\n      const paddingNeeded = remainder === 0 ? 0 : blockSize - remainder\r\n      \r\n      // Add padding if needed\r\n      let paddedData = encryptedData\r\n      if (paddingNeeded > 0) {\r\n        paddedData = Buffer.concat([encryptedData, Buffer.alloc(paddingNeeded, paddingNeeded)])\r\n        console.log('Added PKCS#7 padding:', paddingNeeded, 'bytes')\r\n      }\r\n      \r\n      // Create decipher with manual padding handling\r\n      const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv)\r\n      decipher.setAutoPadding(false)\r\n      \r\n      // Decrypt the data\r\n      let decrypted = decipher.update(paddedData)\r\n      decrypted = Buffer.concat([decrypted, decipher.final()])\r\n      \r\n      // Remove PKCS#7 padding manually\r\n      const lastByte = decrypted[decrypted.length - 1]\r\n      if (lastByte <= blockSize) {\r\n        let validPadding = true\r\n        for (let i = 1; i <= lastByte; i++) {\r\n          if (decrypted[decrypted.length - i] !== lastByte) {\r\n            validPadding = false\r\n            break\r\n          }\r\n        }\r\n        \r\n        if (validPadding) {\r\n          decrypted = decrypted.slice(0, decrypted.length - lastByte)\r\n        }\r\n      }\r\n      \r\n      // Convert to string and clean up non-printable characters\r\n      let result = decrypted.toString('utf8')\r\n      console.log('Raw decrypted result (first 100 chars):', result.substring(0, 100))\r\n      \r\n      // Clean the result by removing non-printable characters\r\n      const cleanedResult = result.replace(/[\\x00-\\x1F\\x7F-\\x9F]/g, '')\r\n      \r\n      // Try to find a valid JSON object in the result\r\n      const jsonMatch = cleanedResult.match(/\\{[^\\{\\}]*(?:\\{[^\\{\\}]*\\}[^\\{\\}]*)*\\}/)\r\n      if (jsonMatch) {\r\n        console.log('Found JSON object in decrypted data')\r\n        try {\r\n          const parsedJson = JSON.parse(jsonMatch[0])\r\n          console.log('Successfully parsed JSON from decrypted data')\r\n          return parsedJson\r\n        } catch (jsonError) {\r\n          console.log('Found JSON-like content but failed to parse:', jsonError.message)\r\n        }\r\n      }\r\n      \r\n      // If we couldn't find valid JSON, try to extract key-value pairs\r\n      const keyValuePairs = cleanedResult.match(/([\\w]+)=([^&]+)&?/g)\r\n      if (keyValuePairs && keyValuePairs.length > 0) {\r\n        console.log('Found key-value pairs in decrypted data')\r\n        const resultObj = {}\r\n        keyValuePairs.forEach(pair => {\r\n          const [key, value] = pair.replace('&', '').split('=')\r\n          if (key && value) {\r\n            resultObj[key] = value\r\n          }\r\n        })\r\n        \r\n        if (Object.keys(resultObj).length > 0) {\r\n          console.log('Created object from key-value pairs')\r\n          return resultObj\r\n        }\r\n      }\r\n    } catch (approachError) {\r\n      console.log('Custom padding approach failed:', approachError.message)\r\n    }\r\n    \r\n    // APPROACH 2: Try direct hex decoding with auto padding\r\n    try {\r\n      const encryptedData = Buffer.from(encResponse, 'hex')\r\n      const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv)\r\n      let decrypted = decipher.update(encryptedData)\r\n      decrypted = Buffer.concat([decrypted, decipher.final()])\r\n      \r\n      const result = decrypted.toString('utf8')\r\n      console.log('Direct hex approach succeeded')\r\n      \r\n      try {\r\n        return JSON.parse(result)\r\n      } catch (jsonError) {\r\n        console.log('JSON parsing failed, returning raw result')\r\n        return { rawResponse: result }\r\n      }\r\n    } catch (directError) {\r\n      console.log('Direct hex approach failed:', directError.message)\r\n    }\r\n    \r\n    // APPROACH 3: Try base64 decoding\r\n    try {\r\n      const encryptedData = Buffer.from(encResponse, 'base64')\r\n      const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv)\r\n      let decrypted = decipher.update(encryptedData)\r\n      decrypted = Buffer.concat([decrypted, decipher.final()])\r\n      \r\n      const result = decrypted.toString('utf8')\r\n      console.log('Base64 approach succeeded')\r\n      \r\n      try {\r\n        return JSON.parse(result)\r\n      } catch (jsonError) {\r\n        console.log('JSON parsing failed, returning raw result')\r\n        return { rawResponse: result }\r\n      }\r\n    } catch (base64Error) {\r\n      console.log('Base64 approach failed:', base64Error.message)\r\n    }\r\n    \r\n    // APPROACH 4: Return a fallback response with the error\r\n    console.log('All decryption approaches failed, returning fallback response')\r\n    return {\r\n      status: 'error',\r\n      message: 'Failed to decrypt the payment response',\r\n      encryptedResponse: encResponse.substring(0, 50) + '...',\r\n      clientCode: 'INDR81',\r\n      timestamp: new Date().toISOString()\r\n    }\r\n  } catch (error) {\r\n    console.error('Decryption error:', error)\r\n    // Instead of throwing, return an error object\r\n    return {\r\n      status: 'error',\r\n      message: `Failed to decrypt response: ${error.message}`,\r\n      timestamp: new Date().toISOString()\r\n    }\r\n  }\r\n}\r\n\r\nexport async function GET(request) {\r\n  try {\r\n    const { searchParams } = new URL(request.url)\r\n    const clientCode = searchParams.get('clientCode')\r\n    const encResponse = searchParams.get('encResponse')\r\n\r\n    console.log('Payment callback received:', { clientCode, encResponse })\r\n\r\n    if (!clientCode || !encResponse) {\r\n      return NextResponse.json({\r\n        status: 'error',\r\n        message: 'Missing required parameters',\r\n        missing: {\r\n          clientCode: !clientCode,\r\n          encResponse: !encResponse\r\n        }\r\n      }, { status: 400 })\r\n    }\r\n\r\n    // Parse the encrypted response from SabPaisa using server-side compatible method\r\n    const authKey = process.env.AUTH_KEY || process.env.NEXT_PUBLIC_AUTH_KEY || \"doJx8Ihyb2s/sh1pbYEDfa6JdsogEYMXKEoPF/BEwrg=\"\r\n    const authIV = process.env.AUTH_IV || process.env.NEXT_PUBLIC_AUTH_IV || \"iw/0vT01OWRph/rQplst/W7k423JXrgo4xBn3gXPsIDXTTXE461f4V4QYKGQ8wTe\"\r\n\r\n    let decryptedData = decryptSabPaisaResponse(encResponse, authKey, authIV)\r\n    console.log('Decrypted payment data:', decryptedData)\r\n    console.log('Decrypted data type:', typeof decryptedData)\r\n    console.log('Decrypted data keys:', decryptedData ? Object.keys(decryptedData) : 'No keys')\r\n    \r\n    // Check if decryption returned an error object\r\n    if (decryptedData && decryptedData.status === 'error') {\r\n      console.error('Error decrypting payment response:', decryptedData.message)\r\n      return NextResponse.json({\r\n        status: 'error',\r\n        message: 'Payment data decryption failed: ' + decryptedData.message,\r\n        encResponseFormat: {\r\n          length: encResponse ? encResponse.length : 0,\r\n          sample: encResponse ? encResponse.substring(0, 50) + '...' : 'empty',\r\n          isHex: /^[0-9A-Fa-f]+$/.test(encResponse || ''),\r\n          isBase64: /^[A-Za-z0-9+/=]+$/.test(encResponse || '')\r\n        }\r\n      }, { status: 400 })\r\n    }\r\n\r\n    if (!decryptedData) {\r\n      return NextResponse.json({\r\n        status: 'error',\r\n        message: 'Empty decrypted response',\r\n        samplePayloadKeys: ['raw']\r\n      }, { status: 400 })\r\n    }\r\n\r\n    // Check if decrypted data is actually an object with expected fields\r\n    if (typeof decryptedData !== 'object' || decryptedData === null) {\r\n      console.error('Decrypted data is not an object:', decryptedData)\r\n      return NextResponse.json({\r\n        status: 'error',\r\n        message: 'Decrypted response is not a valid object',\r\n        decryptedData: decryptedData,\r\n        samplePayloadKeys: ['raw']\r\n      }, { status: 400 })\r\n    }\r\n\r\n    // Extract payment status and transaction ID\r\n    // Only proceed if decryption was successful\r\n    if (decryptedData && decryptedData.status !== 'error') {\r\n      const paymentStatus = decryptedData.status || decryptedData.paymentStatus || decryptedData.statusCode\r\n      const transactionId = decryptedData.txnId || decryptedData.transactionId || decryptedData.clientTxnId || ''\r\n      const clientTxnId = decryptedData.clientTxnId || decryptedData.clientTransactionId || ''\r\n      \r\n      console.log('Payment status:', paymentStatus)\r\n      console.log('Transaction ID:', transactionId)\r\n      console.log('Client Transaction ID:', clientTxnId)\r\n      \r\n      // Map payment status from SabPaisa response\r\n      const mapPaymentStatus = (paymentData) => {\r\n        const rawStatus = (paymentData.status || paymentData.STATUS || paymentData.paymentStatus || '').toString().toUpperCase()\r\n        const statusCode = (paymentData.statusCode || paymentData.STATUS_CODE || paymentData.gatewayResponseCode || '').toString()\r\n        const respMsg = (paymentData.sabpaisaMessage || paymentData.responseMessage || paymentData.RESPONSE_MESSAGE || paymentData.message || paymentData.bankMessage || '').toString()\r\n\r\n        // Known success signals\r\n        const isExplicitSuccess = rawStatus === 'SUCCESS' || rawStatus === 'SUCCESSFUL' || rawStatus === 'COMPLETED'\r\n        if (isExplicitSuccess) {\r\n          return { status: 'success', message: respMsg || 'Payment completed successfully!' }\r\n        }\r\n\r\n        // Known failure signals\r\n        const isExplicitFailure = rawStatus === 'FAILED' || rawStatus === 'FAILURE' || rawStatus === 'CANCELLED' || rawStatus === 'CANCELED' || rawStatus === 'ERROR' || rawStatus === 'REJECTED'\r\n        if (isExplicitFailure) {\r\n          return { status: 'cancelled', message: respMsg || 'Payment was cancelled or failed.' }\r\n        }\r\n\r\n        // Check status codes for additional validation\r\n        if (statusCode === '0000' || statusCode === '00') {\r\n          return { status: 'success', message: respMsg || 'Payment completed successfully!' }\r\n        }\r\n        \r\n        if (statusCode && statusCode !== '0000' && statusCode !== '00') {\r\n          return { status: 'cancelled', message: respMsg || 'Payment failed with status code: ' + statusCode }\r\n        }\r\n\r\n        // Otherwise keep pending\r\n        return { status: 'pending', message: respMsg || 'Payment is being processed...' }\r\n      }\r\n\r\n      const statusInfo = mapPaymentStatus(decryptedData)\r\n\r\n      // Debug: Log all available fields in decrypted data\r\n      console.log('Available fields in decrypted data:', Object.keys(decryptedData))\r\n      console.log('Looking for specific fields:')\r\n      console.log('- payerName:', decryptedData.payerName, 'PAYER_NAME:', decryptedData.PAYER_NAME)\r\n      console.log('- payerEmail:', decryptedData.payerEmail, 'PAYER_EMAIL:', decryptedData.PAYER_EMAIL)\r\n      console.log('- statusCode:', decryptedData.statusCode, 'STATUS_CODE:', decryptedData.STATUS_CODE)\r\n      console.log('- Full decrypted object:', JSON.stringify(decryptedData, null, 2))\r\n\r\n      // Extract fields with multiple fallback options\r\n      const extractField = (obj, fieldNames, defaultValue = '') => {\r\n        for (const fieldName of fieldNames) {\r\n          if (obj[fieldName] !== undefined && obj[fieldName] !== null && obj[fieldName] !== '') {\r\n            return obj[fieldName]\r\n          }\r\n        }\r\n        return defaultValue\r\n      }\r\n\r\n      // Build update payload for Site B with required fields\r\n      const updatePayload = {\r\n        txnId: extractField(decryptedData, ['clientTxnId', 'CLIENT_TXN_ID', 'txnId'], ''),\r\n        sabpaisaTxnId: extractField(decryptedData, ['sabpaisaTxnId', 'SABPAISA_TXN_ID', 'txnId'], ''),\r\n        referenceId: extractField(decryptedData, ['clientTxnId', 'CLIENT_TXN_ID', 'txnId'], ''),\r\n        amount: Number(extractField(decryptedData, ['amount', 'AMOUNT'], 0)),\r\n        status: statusInfo.status === 'success' ? 'SUCCESS' : (statusInfo.status === 'cancelled' ? 'FAILED' : 'PENDING'),\r\n        responseMessage: extractField(decryptedData, ['sabpaisaMessage', 'responseMessage', 'message', 'bankMessage'], statusInfo.message),\r\n        userId: extractField(decryptedData, ['payerEmail', 'userId', 'PAYER_EMAIL'], ''),\r\n        type: extractField(decryptedData, ['type'], 'PAYMENT'),\r\n        description: extractField(decryptedData, ['description'], 'Payment'),\r\n        // Required fields for Site B validation with multiple fallbacks\r\n        payerName: extractField(decryptedData, ['payerName', 'PAYER_NAME', 'customerName', 'CUSTOMER_NAME'], 'Unknown User'),\r\n        payerEmail: extractField(decryptedData, ['payerEmail', 'PAYER_EMAIL', 'email', 'EMAIL', 'userId'], ''),\r\n        statusCode: extractField(decryptedData, ['statusCode', 'STATUS_CODE', 'gatewayResponseCode', 'responseCode'], statusInfo.status === 'success' ? '0000' : '9999'),\r\n        metadata: { ...decryptedData },\r\n        createdAt: new Date().toISOString()\r\n    }\r\n\r\n      console.log('Built payload for Site B:', updatePayload)\r\n      console.log('Required fields check:')\r\n      console.log('- payerName:', updatePayload.payerName, '(required)')\r\n      console.log('- payerEmail:', updatePayload.payerEmail, '(required)')\r\n      console.log('- statusCode:', updatePayload.statusCode, '(required)')\r\n\r\n      // Send to Site B\r\n      try {\r\n        const siteBResponse = await sendTransactionToSiteB(updatePayload)\r\n        console.log('Site B response:', siteBResponse)\r\n\r\n        // Check if this is a browser request (redirect to response page)\r\n        // or an API request (return JSON)\r\n        const acceptHeader = request.headers.get('accept') || ''\r\n        const isBrowserRequest = acceptHeader.includes('text/html') || \r\n                                 request.headers.get('user-agent')?.includes('Mozilla')\r\n        \r\n        // If browser request, redirect to response page with parameters\r\n        if (isBrowserRequest) {\r\n          const redirectUrl = new URL('/response', request.url)\r\n          redirectUrl.searchParams.set('encResponse', encResponse)\r\n          redirectUrl.searchParams.set('clientCode', clientCode)\r\n          redirectUrl.searchParams.set('success', statusInfo.status === 'success' ? 'true' : 'false')\r\n          \r\n          console.log('Redirecting browser to response page:', redirectUrl.toString())\r\n          return NextResponse.redirect(redirectUrl.toString(), { status: 302 })\r\n        }\r\n\r\n        // For API requests, return JSON\r\n        return NextResponse.json({\r\n          status: 'success',\r\n          message: 'Payment callback processed successfully',\r\n          paymentStatus: statusInfo.status,\r\n          paymentMessage: statusInfo.message,\r\n          siteBResponse: siteBResponse\r\n        }, { status: 200 })\r\n\r\n      } catch (siteBError) {\r\n        console.error('Error sending to Site B:', siteBError)\r\n        \r\n        // Check if this is a browser request\r\n        const acceptHeader = request.headers.get('accept') || ''\r\n        const isBrowserRequest = acceptHeader.includes('text/html') || \r\n                                 request.headers.get('user-agent')?.includes('Mozilla')\r\n        \r\n        // If browser request, still redirect to response page even if Site B failed\r\n        if (isBrowserRequest) {\r\n          const redirectUrl = new URL('/response', request.url)\r\n          redirectUrl.searchParams.set('encResponse', encResponse)\r\n          redirectUrl.searchParams.set('clientCode', clientCode)\r\n          redirectUrl.searchParams.set('success', 'false')\r\n          redirectUrl.searchParams.set('error', 'Failed to update Site B')\r\n          \r\n          console.log('Redirecting browser to response page (Site B error):', redirectUrl.toString())\r\n          return NextResponse.redirect(redirectUrl.toString(), { status: 302 })\r\n        }\r\n        \r\n        return NextResponse.json({\r\n          status: 'error',\r\n          message: 'Payment processed but failed to update Site B',\r\n          paymentStatus: statusInfo.status,\r\n          paymentMessage: statusInfo.message,\r\n          siteBError: siteBError.message\r\n        }, { status: 200 }) // Still return 200 since payment was processed\r\n      }\r\n    } else {\r\n      // If decryption returned an error object\r\n      return NextResponse.json({\r\n        status: 'error',\r\n        message: 'Failed to decrypt payment response',\r\n        error: decryptedData.message\r\n      }, { status: 400 })\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error('Payment callback error:', error)\r\n    return NextResponse.json({\r\n      status: 'error',\r\n      message: 'Internal server error',\r\n      error: error.message\r\n    }, { status: 500 })\r\n  }\r\n}\r\n\r\nexport async function POST(request) {\r\n  // Handle POST requests if needed (some payment gateways use POST)\r\n  return GET(request)\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}